from .pid import PID
from .fsm import FSM
from .llm import FakeLLM


class AITL:
    """
    Adaptive Intelligent Tuned Loop (AITL)

    AITL integrates a three-layer adaptive control architecture:

        - Inner layer : PID controller
        - Middle layer: FSM (supervisory logic)
        - Outer layer: LLM-based adaptive gain tuning

    The FSM determines when gain tuning is necessary, and the LLM adjusts
    the PID gains accordingly. This architecture improves robustness and
    tracking performance under disturbances or parameter changes.
    """

    def __init__(self, pid: PID, fsm: FSM, llm: FakeLLM):
        self.pid = pid
        self.fsm = fsm
        self.llm = llm

    # -----------------------------------
    # Reset internal states
    # -----------------------------------
    def reset(self) -> None:
        """
        Reset controller states:
        - PID internal memory
        - FSM state
        """
        self.pid.reset()
        self.fsm.reset()

    # -----------------------------------
    # Main control step
    # -----------------------------------
    def step(self, r: float, x: float, dt: float = 0.01):
        """
        Compute control input using the full AITL workflow.

        Parameters
        ----------
        r : float
            Reference value.
        x : float
            Current plant output.
        dt : float
            Sampling time [s].

        Returns
        -------
        (u, state) : tuple(float, str)
            u      : Control input generated by PID.
            state  : FSM state after transition.
        """
        if r is None or x is None:
            raise ValueError("Reference r and state x must not be None.")
        if dt <= 0:
            raise ValueError("dt must be positive.")

        # Tracking error
        e = r - x

        # FSM state transition (based on error magnitude)
        state = self.fsm.transition(e)

        # LLM tuning is triggered only in TUNE state
        if state == FSM.TUNE:
            self.llm.tune(self.pid, e)

        # PID control
        u = self.pid(e, dt)

        return u, state
